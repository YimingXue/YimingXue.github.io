<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My New Hugo Site</title>
    <link>http://YimingXue.github.io/</link>
    <description>Recent content on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="http://YimingXue.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>http://YimingXue.github.io/post/c&#43;&#43;%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://YimingXue.github.io/post/c&#43;&#43;%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</guid>
      <description>C++常用方法 vector使用总结   使用时包含头文件： #include&amp;lt;vector&amp;gt;
  C++中的STL指代的是Standard Template Library，标准模板库，惠普实验室开发的一系列软件的统称。
vector的初始化 #include&amp;lt;vector&amp;gt; // 定义10个整型元素的向量，这种方法没有给出初值，此时库会创建一个值初始化的元素初值， // 并把它赋给容器中的所有元素 vector&amp;lt;int&amp;gt; a(10); // 定义10个整型元素的向量，并且给出每个元素的初值为1 vector&amp;lt;int&amp;gt; a(10, 1); // 用b向量来创建a向量，整体复制性赋值 vector&amp;lt;int&amp;gt; a(b); // 定义了a向量中的值为b中第0个到第2个元素 vector&amp;lt;int&amp;gt; a(b.begin(), b.begin()+3); // 从数组中获得初值 int b[7] = {1,2,3,4,5,6,7}; vector&amp;lt;int&amp;gt; a(b, b+7); vector对象的几个重要操作 #include&amp;lt;vector&amp;gt;a.assign(b.begin(), b.begin()+3); // 将向量b的0~2个元素构成向量赋值给向量a  a.assign(4, 2); // 初始化一个整型元素向量，但未赋初值，使向量a中只包含4个元素，且每个元素为2  a.back(); // 返回向量a中最后一个元素  a.front(); // 返回向量a中第一元素  a[i]; // 返回向量a中的第i个元素，当且仅当a[i]存在  a.clear();// 清空向量a中的元素  a.empty(); // 判断向量a是否为空，空则返回True，不空则返回False  a.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://YimingXue.github.io/post/docker%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://YimingXue.github.io/post/docker%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</guid>
      <description>Docker结合深度学习框架 安装指定版本Docker CE 下面这两种方法都可以用来安装Docker CE：
plan A： sudo apt install curl curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - echo &amp;#34;deb [arch=amd64] https://download.docker.com/linux/ubuntu xenial edge&amp;#34; | sudo tee /etc/apt/sources.list.d/docker.list sudo apt-get update &amp;amp;&amp;amp; sudo apt-get install -y docker-ce=18.03.1~ce-0~ubuntu plan B： sudo apt install curl curl -fsSL get.docker.com -o get-docker.sh sudo sh get-docker.sh --mirror Aliyun 启动Docker CE sudo systemctl enable docker sudo systemctl start docker # 重新启动docker命令（没有需要不用执行） sudo systemctl restart docker 建立docker用户组 # 建立docker组 sudo groupadd docker # 将当前用户加入docker组 sudo usermod -aG docker $USER 安装Nvidia Docker2 Nvidia Docker2项目的主页</description>
    </item>
    
    <item>
      <title></title>
      <link>http://YimingXue.github.io/post/git%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://YimingXue.github.io/post/git%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</guid>
      <description>注：以下的操作都是在linux系统上进行的
1、注册github账户以及创建仓库 2、安装Git  打开控制台，然后通过包管理安装，在Ubuntu上输入命令  sudo apt-get install git-all3、配置Git （1）本地创建ssh key  以下代码中your_email为你的邮箱，即你在github上注册的那个邮箱。之后一路回车，最后会在会在默认文件id_rsa上生成ssh key。打开id_rsa.pub，复制里面的key，然后回到github网站的settings，选择SSH Keys，Add SSH Key，title随便填，粘贴key，然后点击 Add key 按钮。  ssh-keygen -t rsa -C “your_email”**（2）验证是否连接成功 **  输入以下命令验证是否连接成功，如果成功连接github会看到以下结果：  ssh -T git@github.comYou’ve successfully authenticated, but GitHub does not provide shell access （3）配置用户的用户名和email（这些内容会出现在你的每一个提交（commit）里面）  Git配置信息分为全局和项目两种，以下带“–global”参数的命令是全局配置，它会影响本机上的每一个Git项目。  git config --global user.name &amp;quot;xueyiming&amp;quot;git config --global user.email &amp;quot;xueyimingshdx@126.com&amp;quot; Git也可以为每个项目设定不同的配置信息，在命令行环境，进入Git项目所在目录，执行下面的命令（这个命令要在下面git init之后执行，否则没有.git文件夹）   git config user.name &amp;quot;your xueyiming&amp;quot;git config user.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://YimingXue.github.io/post/linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://YimingXue.github.io/post/linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</guid>
      <description>进度表  实验1：Linux系统简介 实验2：基本概念及操作 实验3：用户及文件权限管理 实验4：Linux目录结构及文件基本操作 实验5：环境变量与文件查找  命令行操作体验 常用快捷键    操作 功能     Ctrl+d 键盘输入结束或退出终端   Ctrl+s 暂停当前程序，暂停后按下任意键恢复运行   Ctrl+a 将光标移至输入行头，相当于Home键   Ctrl+e 将光标移至输入行末，相当于End键   Ctrl+k 删除从光标所在位置到行末    Shell常用通配符    匹配0或多个字符       字符 含义     * 匹配0或多个字符   ？ 匹配任意一个字符   [list] 匹配list中的任意单一字符   [^list] 匹配除list中的任意单一字符以外的字符   {string1, string2, &amp;hellip;} 匹配string1或string2（或更多）其一字符串   {c1, &amp;hellip;, c2} 匹配c1-c2中全部字符，如1.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://YimingXue.github.io/post/matlab%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://YimingXue.github.io/post/matlab%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</guid>
      <description>Matlab使用记录 matlab使用心得  matlab是按列存储数据的 matlab中for是一种非常耗时的语句  matlab中format的使用方法 针对数据的显示形式控制，matlab中有专用命令format，但该命令不影响数据的储存形式和计算精度
format compact，压缩空格
matlab中magic方法 M = magic(n)，生成一个n*n的矩阵，矩阵元素是由整数1到$n^2$组成的并且任意行、任意列的和都相等，阶数n必须是大于等于3的标量
matlab中自定义函数 注：这种方法要求定义函数必须单独写一个M文件，不能与调用的命令写在同一个M文件中
% 自定义函数文件：mylfg.m function y=mylfg(x) % 注意：函数名（mylfg）必须与文件名（mylfg.m）一致 y=x^(1/3); end matlab中fprintf函数 % 打印的结果为the value of pi is 3.14，后面带有一个换行符。转义序列%6.2f代表在本函数中的第一个数据项将占有6个字符宽度，小数点后有2位小数 &amp;gt;&amp;gt; fprintf(&amp;#39;the value of pi is %6.2f\n&amp;#39;,pi) the value of pi is 3.14 matlab保存和导入工作区变量mat文件  使用save bianld.mat可以保存工作区变量 使用load bianld.mat可以导入工作区变量 mat文件名称自定义，使用clear a或clear可以清空工作区指定变量或所有变量 save(&amp;lsquo;filename&amp;rsquo;, &amp;lsquo;var1&amp;rsquo;, &amp;lsquo;var2&amp;rsquo;, &amp;hellip;)：保存指定的变量在 filename 指定的文件中  matlab中size函数 size函数是用来求矩阵的大小的，假设A是一个3x4的二维矩阵
 s=size(A)，返回一个行向量s，s的第一个元素是矩阵的行数，第二个元素是矩阵的列数 [r,c]=size(A)，将矩阵A的行数返回到第一个输出变量r，将矩阵的列数返回到第二个输出变量c r=size(A,1); c=size(A,2)，第一句返回的是矩阵A的行数，第二句返回的是矩阵A的列数  matlab大段注释的方法   快捷键：Ctrl+R注释，Ctrl+T取消注释</description>
    </item>
    
    <item>
      <title></title>
      <link>http://YimingXue.github.io/post/python%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://YimingXue.github.io/post/python%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</guid>
      <description>python Python常用方法记录 python中list和str互换 list转str
string = &amp;#39;&amp;#39;.join(list) # list中的元素需要为字符型，若为整型，则需要先转换成字符型再转成str类型 string = &amp;#39;&amp;#39;.join([str(item) for item in num_list]) str转list
list(string) Python print 不换行打印 for i in range(0, 5): print(i, end=&amp;#34;&amp;#34;) Python新建文件夹 import os path = &amp;#34;/home/xueyiming/data/&amp;#34; if not os.path.exists(path): os.makedirs(path) Python中lambda表达式、filter和map lambda语句 lambda语句构建一个函数对象，其语法为：lambda(传入参数):(返回值)
g = lambda x: 2 * x + 1 g(5) f = lambda x, y: x + y f(3, 5) 内置函数filter 过滤器：filter。filter接收两个参数，第一个参数是函数或者None，第二个参数是可迭代的数据，filter将可迭代数据中的每一个元素都放入第一个数据进行计算，并返回返回值为True的元素。返回值是一个filter对象，需要转换为列表或者元组进行查看
list(filter(None, [1, 0, False, True])) # 返回：[1, True]，注意返回的是一个新列表，原列表本身是不变的 def odd(x): return x % 2 temp = range(10) show = filter(odd, temp) list(show) # 返回：[1,3,5,7,9] list(filter(lambda x: x % 2, range(10))) # 返回：[1,3,5,7] 内置函数map map方法用于映射，其参数与filter一样，其作用是将序列的每一个元素作为函数的参数进行运算加工，直到所有元素都加工完毕，并返回一个新的序列。map的返回值是map对象，需要转变为列表或元组查看</description>
    </item>
    
    <item>
      <title></title>
      <link>http://YimingXue.github.io/post/pytorch%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://YimingXue.github.io/post/pytorch%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</guid>
      <description>Pytorch使用记录 pytorch数据处理 1. 数据定义 torchvision.datasets (Pytorch框架中有一个非常重要好用的包：torchvision，这个包主要由3个子包组成，分别是：torchvision.datasets, torchvision.models, torchvision.transforms)
主要实现针对不同数据集的处理方法，用来加载数据和处理数据。类的实现需要继承父类==torch.utils.data.Dataset==，主要方法有两个：
  _init_(self, root, train=True, transform=None, target_transform=None, download=False):
该方法用来初始化类和对数据进行加载（有时需要定义一些开关来防止重复处理）。数据的加载就是针对不同的数据，把其data和label（分为训练数据和测试数据）读入内存中。
  _getitem_(self, index):
该方法是把读入的输出传给Pytorch（迭代器的方式）
  ==至此，对数据进行加载，然后处理传给Pytorch已经完成，如果需要对自己的数据进行处理，也是通过修改和增加此部分完成。接下来需要队训练的数据进行处理，比如分批次的大小，随机处理等等。==
2. 数据处理 torchvision.transform.Compose() 通过compose把一些对图像处理的方法集中起来
3. 数据加载 torch.utils.data.DataLoader() 该接口定义在dataloader.py脚本中，只要是用PyTorch来训练模型基本都会用到该接口，该接口主要用来将自定义的数据读取接口的输出或者PyTorch已有的数据读取接口的输入按照batch size封装成Tensor，后续只需要再包装成Variable即可作为模型的输入，因此该接口有点承上启下的作用
def __init__(self, dataset, batch_size=1, shuffle=False, sampler=None, batch_sampler=None, num_workers=0, collate_fn=default_collate, pin_memory=False, drop_last=False, timeout=0, worker_init_fn=None):  dataset：这个就是PyTorch已有的数据读取接口（比如torchvision.datasets.ImageFolder）或者自定义的数据接口的输出，该输出要么是torch.utils.data.Dataset类的对象，要么是继承自torch.utils.data.Dataset类的自定义类的对象 batch_size, shuffle, sampler batch_sampler：RandomSampler类表示随机采样且不重复，所以起到的就是shuffle的作用。BatchSampler类则是把batch size个RandomSampler类对象封装成一个，这样就实现了随机选取一个batch的目的 num_workers：从注释可以看出这个参数必须大于等于0，0的话表示数据导入在主进程中进行，其他大于0的数表示通过多个进程来导入数据，可以加快数据导入速度 collate_fn：用来处理不同情况下的输入dataset的封装，一般采用默认即可，除非你自定义的数据读取输出非常少见 pin_memory：pin_memory (bool, optional): If True, the data loader will copy tensors into CUDA pinned memory before returning them.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://YimingXue.github.io/post/sci%E6%92%B0%E5%86%99%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://YimingXue.github.io/post/sci%E6%92%B0%E5%86%99%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</guid>
      <description>SCI撰写问题记录  这里主要记录一下自己第一篇SCI在撰写过程中遇到的问题和相应的解决方法（说得好像我还会写第二篇一样）。  参考文献整理  文献管理软件（Mendeley, EndNote），又大又全，自动化程度高，学习成本较低，如果你是用word写作推荐之。bibtex格式，自动化程度最高，不过style没有endnote那么全，学习成本较高，但基本可以一劳永逸，而且用LaTeX写很爽，如果你半辈子准备做科研，推荐之。  Mendeley整理参考文献  具体流程参考使用文献管理软件Mendeley插入参考文献和引用，舒服得鸭皮  在word中使用Mendeley整理参考文献  在Google上搜索论文，从Get Citation下载RIS格式引用 将引用导入Mendeley 在word中点击Insert Citation即可  LaTeX介绍、安装教程及基本使用   使用环境： Win10 64位, TeX Live 2018, TeXstudio
  LaTeX是一种基于TEX的排版系统。TEX在不同的硬件和操作系统上有不同的实现版本。这就像C语言，在不同的操作系统中有不同的编译系统，例如Linux下的gcc，Windows下的Visual C++等。有时一种操作系统里也会有好几种的TEX系统，常见的Unix/Linux下的TEX系统是teTEX，windows下则有MiKTEX和fpTEX。
  TeX Live下载安装  TeX Live是TUG (TeX User Group)维护和发布的TeX系统，可以说是“官方”的TeX系统。推荐任何阶段的TeX用户，都尽可能使用TeX Live，以保持在跨操作系统平台、跨用户的一致性。下载地址为TeX Live 2018，安装教程参考TeX Live 2014安装引导流程，记得安装时右键install-tl-advanced.bat，以管理员权限执行。  TeXstudio下载安装  免费软件官网下载即可，链接TeXstudio。具体过程可参考texlive2018和texstudio的安装及汉化教程  CTeX下载安装（没用到）  CTeX指的是CTeX中文套装的简称，是把MiKTEX和一些常用的相关工具，如GSview，WinEdt等包装在一起制作的一个简易安装程序，并对其中的中文支持部分进行了配置，使得安装后马上就可以使用中文。  WinEdt 10.3下载安装、注册激活（没用到）  上面CTeX安装时会清除系统环境变量，令我忙活了大半天，找到win10自带的系统变量，然后重启才能下载WinEdt。下载地址为WinEdt 10.3，选择WinEdt 10.3 (64-bit) [Build: 20180507] (winedt103-64.exe 9.2 MB)下载，安装完成，运行WinEdt，打开Help &amp;raquo; Register WinEdt… 在弹出的对话框里包含Name,Code,Date。对应填入以下信息即可，轻松愉悦。  Name：Cracker TeCHiScyCode：1130140925535334280Date：不用填参考资料：</description>
    </item>
    
    <item>
      <title></title>
      <link>http://YimingXue.github.io/post/%E6%AD%A6%E8%A3%85ubuntu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://YimingXue.github.io/post/%E6%AD%A6%E8%A3%85ubuntu/</guid>
      <description>Ubuntu16.04使用visual-studio-code 安装 使用文档
下载deb包 https://code.visualstudio.com/Download 安装 sudo dpkg -i code_1.19.2-1515599945_amd64.deb 运行 命令行执行code 修改语言 进入命令行：ctrl+shift+p
输入：Configure Language
修改：&amp;quot;locale&amp;quot;:&amp;quot;zh-CN&amp;quot;
概念  配置文件  单次运行一个脚本视为一个task，相应的配置文件为task.json 整个文件夹或者多个文件夹视为一个工作空间，配置文件为settings.json 调试环境的配置文件为launch.json 这些配置文件是需要手动编辑的，编辑完保存好就会代替默认的配置文件生效    小技巧   查看函数或类的定义
Ctrl+鼠标左键点击函数名或者类名即可跳转到定义处
在函数名或者类名上按F2
  更改变量名
在变量名上按F2即可实现重命名变量
  python断点调试
在行号的左边点击即可设置断点，在左边的调试界面可以查看变量的变化
  修改Pylint设置 { &amp;#34;python.jediEnabled&amp;#34;: false, &amp;#34;python.pythonPath&amp;#34;: &amp;#34;/home/xueyiming/anaconda3/bin/python&amp;#34;, &amp;#34;python.autoComplete.extraPaths&amp;#34;: [&amp;#34;/usr/local/lib/python2.7/site-packages&amp;#34;], &amp;#34;python.linting.pylintArgs&amp;#34;: [ &amp;#34;--disable=E1101&amp;#34;, &amp;#34;--disable=E0401&amp;#34;, &amp;#34;--disable-msg=C0103&amp;#34; ] } 问题  Timeout waiting for debugger connection  修改settings.json中的terminal.integrated.shell.windows为&amp;quot;C:\\WINDOWS\\System32\\cmd.exe&amp;quot;即可 解决方案    参考资料  用VSCode写python的正确姿势  Ubuntu安装Python3.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://YimingXue.github.io/post/%E6%AD%A6%E8%A3%85windows/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://YimingXue.github.io/post/%E6%AD%A6%E8%A3%85windows/</guid>
      <description>Windows配置Anaconda2.7环境 需要在系统环境中添加：Anaconda的安装路径，该路径下的Scripts目录以及Library\bin目录
D:\Anaconda\  D:\Anaconda\Scripts D:\Anaconda\Library\bin Windows安装、配置Git 参考资料：
 Git for Windows安装和基本设置 Windows10和Visual Studio Code环境中配置使用Git和GitHub  问题：
 fatal: Could not read from remote repository.  Windows下VScode编译调试C/C++ 参考资料：
 【VSCode】Windows下VSCode编译调试c/c++【更新 2018.03.27】 Visual Studio Code (vscode) 配置C、C++环境/编写运行C、C++（Windows）【真正的小白版】  Win10使用Anaconda安装Tensorflow（CPU版本） 参考资料：
 Win10下用Anaconda安装TensorFlow Win10下用Anaconda安装TensorFlow 之后出现ImportError: No module named &amp;lsquo;tensorflow&amp;rsquo;  Win10在Jupyter Notebook中使用Tensorflow 安装好Tensorflow
 在激活Tensorflow后安装ipython和jupyter：conda install ipython，conda install jupyter 安装python kernel for Tensorflow：ipython kernelspec install-self --user 看到类似结果Installed kernelspec python3 in C:\Users\XXX\Jupyter\kernels\python3  参考资料：Windows环境下安装TensorFlow并在Jupyter notebook上使用</description>
    </item>
    
    <item>
      <title></title>
      <link>http://YimingXue.github.io/post/%E6%AD%A6%E8%A3%85%E7%BB%88%E7%AB%AF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://YimingXue.github.io/post/%E6%AD%A6%E8%A3%85%E7%BB%88%E7%AB%AF/</guid>
      <description>在ubuntu中使用zsh与oh-my-zsh 安装和配置  查看ubuntu中默认安装了哪些shell  cat /etc/shells  查看当前正在运行的是哪个版本的shell  echo $SHELL  安装zsh、git和wget  sudo apt-get install zsh git wget  安装oh-my-zsh  wget --no-check-certificate https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh  替换bash为zsh并重启生效  chsh -s /bin/zsh sudo reboot 使用手册 oh-my-zsh的github项目在此：oh-my-zsh，vim ~/.zshrc可以查看oh-my-zsh的配置文件，主要可以修改两个参数：
 ZSH_THEME=&#39;ys&#39;，这个修改oh-my-zsh的主题 plugins=(git last-working-dir extract z)，这个为oh-my-zsh添加一些插件  常用操作  转换路径时可以省去cd命令，直接输入路径即可 输入d可以查看访问过的路径，然后输入数字就可以直接切换 ctrl+L = clear = 清屏 zsh_stats，查看使用频率前20的命令 ctrl+u 清除一行的命令  添加插件   zsh-autosuggestions
git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions plugins=(zsh-autosuggestions) vim ~/.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://YimingXue.github.io/post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://YimingXue.github.io/post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/</guid>
      <description>熵与信息增益 信息量  信息量是用来衡量一个事件的不确定性的。一个事件发生的概率越大，不确定性越小，则它所携带的信息量就越小 公式：  $I(x_0)=-log(p(x_0))$    熵  熵是用来衡量一个系统的混乱程度的，代表一个系统中信息量的总和；信息量总和越大，表明这个系统不确定性就越大 信息量用来衡量一个事件的不确定度，熵则用来衡量一个系统（也就是所有事件）的不确定度 度量系统中所有事件的不确定度使用的是期望。所以熵是信息量的期望值，它是一个随机变量的确定性的度量，熵越大，变量的取值越不确定；反之，熵越小变量取值就越稳定 公式：  $H(X)=-\sum_{x\in X}^{}{p(x)log(p(x))}$ $H(X)=-\int{}_{x\in X}{p(x)log(p(x))d_x}$    条件熵  条件熵定义为在随机变量X发生的前提下，随机变量Y发生所带来的熵，用$H(Y|X)$表示，用来衡量在已知随机变量X的前提下随机变量Y的不确定性 公式：  $H(Y|X)=H(X,Y)-H(X)=-\sum_{x,y}{p(x,y)log(p(y|x))}$，(X,Y)发生所包含的熵减去X单独发生包含的熵    相对熵(relative entropy)  相对熵(relative entropy)又称为KL散度(Kullback-Leibler divergence)，KL距离，是两个随机分布距离的度量。记为$D_{KL}(p||q)$，表示在真实分布为p的前提下，使用q分布进行编码相对于使用真实分布p进行(即最优编码)所多出来的bit数 公式：  $D_{KL}(p||q)=E_p[log\frac{p(x)}{q(x)}]=\sum_{x\in X}{p(x)log\frac{p(x)}{q(x)}}=H_p(q)-H(p)$，$H_p(q)$表示在p分布下，使用q进行编码需要的bit数；$H(p)$表示对与真实分布p所需要的最小编码bit数    交叉熵   交叉熵反应的是分布p和q的相似程度
  公式：
  $CE(H(p,q))=E_p(-log(q))=\sum_{x\in X}{p(x)log(q(x))}=H(p)+D_{KL}(p||q)$
​ $=-[plog(q)+(1-p)log(1-q)]$
​ $=-[ylog(h_{\theta}{x})+(1-y)log(1-h_{\theta}(x))]$
    ==在TensorFlow中实现交叉熵==
 cross_entropy = -tf.reduce_mean(y_ * tf.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://YimingXue.github.io/post/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://YimingXue.github.io/post/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</guid>
      <description>科学上网ing 小飞机官方网址
Gitup安装教程
Linux科学上网指南 一、准备 Shadowsocks-Qt5 sudo add-apt-repository ppa:hzwhuang/ss-qt5 sudo apt-get update sudo apt-get install shadowsocks-qt5 Shadowsocks-Qt5下载完成后可通过gui-config.json导入链接，也可手动连接。
pip sudo apt-get install python-pip python-dev build-essential sudo pip install --upgrade pip sudo pip install --upgrade virtualenv GenPAC sudo pip install genpac sudo pip install --upgrade genpac 必须准备工作完成以后才能开始下面的事情哦~
(1) 进入终端，Ctrl+Alt+T，cd到你希望生成文件存放的位置 例如：
cd /home/xueyiming/software (2) 执行下面的语句
sudo genpac --proxy=&amp;#34;SOCKS5 127.0.0.1:1080&amp;#34; --gfwlist-proxy=&amp;#34;SOCKS5 127.0.0.1:1080&amp;#34; -o autoproxy.pac --gfwlist-url=&amp;#34;https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&amp;#34; 注意：
 上面语句中127.0.0.1:1080应按照自己的情况填写。 如果出现下面这种报错：  fetch gfwlist fail. online: https://raw.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://YimingXue.github.io/post/%E9%AB%98%E5%85%89%E8%B0%B1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://YimingXue.github.io/post/%E9%AB%98%E5%85%89%E8%B0%B1/</guid>
      <description>混合像元解混  端元提取  从图像中抽取或计算出端元的过程称为端元提取   丰度解混  求解各个端元对应丰度值的过程称为丰度估计   光谱混合模型是建立在线性混合的假设基础上进行的  高光谱图像处理之 亚像素目标检测 准备内容：研究背景1分钟，现状1分钟（只讲总结性的结论），目前存在的问题（2分钟），研究的创新点（4分钟），实验设计（7分）说清楚。
研究背景 课题研究的是高光谱图像处理中的亚像素目标检测问题。
研究现状  基于二阶或高阶统计量的算法，CME算法、ACE算法  CEM算法主要思想是设计一个FIR线性滤波器，使得在满足约束条件式的情况下滤波器的输出能量最小。    目前存在的问题 针对亚像素目标所占丰度较低的情况下，检测效果不佳
研究的创新点 使用孪生网络（一种用来做验证的网络）来判别当前像素点是否和目标像素点属于同一类
实验设计  影响因素：亚像素目标丰度、高光谱图像背景复杂程度  丰度：10%、1%，还需要根据实际实验目的进行设计 高光谱图像：图像尺寸大小（场地限制）、背景多样性 外观属性是否一致对结果的影响   可能遇到的问题  高光谱仪的空间分辨率是否会太高 如何定标       材质     碳钢珠 （1mm/1.5mm/2mm/2.5mm/3mm/3.5mm）   塑料珠（3mm/4mm）        空间分辨率为3mm     弹珠尺寸 丰度     1mm 8.</description>
    </item>
    
  </channel>
</rss>